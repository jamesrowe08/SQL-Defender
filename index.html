<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body onload="startGame()">
<script>

    var wattImage = new Image();
    var mongoImage = new Image();
    var backgroundImage = new Image();

    var wattLoaded = false;
    var mongoLoaded = false;
    var backgroundLoaded = false;

    var canvas = document.createElement('canvas');
    var context;

    var canvasWidth = 1224;
    var canvasHeight = 768;

    var currentShotId = 0;
    var currentEnemyId = 0;

    var currentEnemies = [];
    var currentShots = [];
    var currentBombs = [];

    var drawInterval;
    var spawnEnemyInterval;
    var timerInterval;

    var timer = 0;

    function startGame() {
        this.context = this.canvas.getContext("2d");
        document.body.appendChild(canvas);

        wattImage.src = "watt.jpg";
        wattImage.onload = function () {
            wattLoaded = true;
        }
        mongoImage.src = "mongo.png";
        mongoImage.onload = function() {
            mongoLoaded = true;
        }
        backgroundImage.src = "sqlbackground.jpg";
        backgroundImage.onload = function() {
            backgroundLoaded = true;
        }

        keyBindings();
        drawInterval = setInterval(drawAllEntities, 50);
        spawnEnemyInterval = setInterval(spawnEnemiesIfNeeded, 1000);
        timerInterval = setInterval(function() {
            timer++;
        }, 1000);
    }


    function keyBindings() {
        document.onkeydown = function (e) {
            e = e || window.event;
            switch (e.which || e.keyCode) {
                case 37: // left
                    watt.xPos = watt.xPos - 10;
                    break;
                case 38: // up
                    watt.yPos = watt.yPos - 10;
                    break;
                case 39: // right
                    watt.xPos = watt.xPos + 10;
                    break;
                case 40: // down
                    watt.yPos = watt.yPos  + 10;
                    break;
                case 32: //spacebar
                    watt.shoot();
                    break;
                case 66: //b
                    watt.dropBomb();
                    break;
                default:
                    return; // exit this handler for other keys
            }
        }
    }

    function drawAllEntities() {
        gameArea.clear();

        gameArea.draw();

        watt.draw();

        for(var i = 0; i < this.currentShots.length; i++) {
            currentShots[i].draw();
        }

        for(var i =0; i < this.currentEnemies.length; i++) {
            currentEnemies[i].draw();
            currentEnemies[i].doMove();
        }

        for(var i = 0; i < this.currentBombs.length; i++) {
            currentBombs[i].draw();
        }
    }

    var gameArea = {
        draw: function () {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.position = "absolute";
            canvas.style.border = "1px solid";
            if(backgroundLoaded) {
                context.drawImage(backgroundImage, 0, 0, canvasWidth, canvasHeight);
            }
            context.fillStyle = 'white';
            context.font = '20pt Calibri';
            context.fillText("Time on the soapbox: " + timer, 20, 40);
        },
        drawGameOver: function() {
            context.fillStyle = 'black';
            context.font = '30pt Calibri';
            wrapText(context, "GAME OVER                                                         Watt fought as hard as he could, but alas: SQL Server was no more. MongoDB and it's endless features (Webscale to name one) conquered SQL Server in all it's glory.", 200, 100, 800, 100);
        },
        clear: function () {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

    }


    var watt = {
        img : document.createElement('IMG'),
        yPos: this.canvas.height / 2,
        xPos: 10,
        draw: function() {
            if(wattLoaded) {
                context.drawImage(wattImage, watt.xPos, watt.yPos, 50, 50);
            }
        },
        shoot: function() {
            var shot = {
                id: currentShotId++,
                xPos : watt.xPos,
                yPos : watt.yPos,
                draw: function() {
                    context.fillStyle = 'white';
                    context.font = '12pt Calibri';
                    context.fillText("DACPAC", this.xPos, this.yPos);
                    this.xPos = this.xPos + 50;
                    if(this.xPos > canvasWidth) {
                        removeBullet(this);
                    }

                    for(var i =0; i < currentEnemies.length; i++) {
                        if (currentEnemies[i].xPos < this.xPos + 10 &&
                                currentEnemies[i].xPos + 100 > this.xPos &&
                                currentEnemies[i].yPos < this.yPos + 10 &&
                                100 + currentEnemies[i].yPos > this.yPos) {
                             enemyHit(i);
                            removeBullet(this);
                        }
                    }
                }
            }
            currentShots.push(shot);
        },
        dropBomb: function() {
            for(var x = -20; x <= 20; x = x + 5) {
                for(var y = -20; y <= 20; y = y + 5) {
                    currentBombs.push(createBomb(x,y));
                }
            }
            currentEnemies = [];
        }
    }

    function createBomb(movementX, movementY) {
        return bomb = {
            xPos: watt.xPos,
            yPos: watt.yPos,
            movementX: movementX,
            movementY: movementY,
            bombTime: timer,
            draw: function() {
                //Clear bomb from array
                if(timer - this.bombTime > 5) {
                    currentBombs = [];
                }
                context.fillText("SELECT * FROM AssWhooping", this.xPos, this.yPos);
                this.xPos = this.movementX + this.xPos;
                this.yPos = this.movementY + this.yPos;
            }
        }
    }

    function createMongoEnemy() {
        return mongoEnemy = {
            id: currentEnemyId++,
            health: 100,
            xPos: canvasWidth + 10,
            yPos: Math.floor((Math.random() * canvasHeight) + 1),
            draw: function () {
                if(mongoLoaded) {
                    context.drawImage(mongoImage, this.xPos, this.yPos, 100, 100);
                }
            },
            doMove: function() {
                if(this.xPos < 0) {
                    var index = currentEnemies.indexOf(this);
                    if(index != -1) {
                        currentEnemies.splice(index, 1);
                    }
                }
                if (this.xPos < watt.xPos + 50 &&
                        this.xPos + 100 > watt.xPos &&
                        this.yPos < watt.yPos + 50 &&
                        100 + this.yPos > watt.yPos) {
                    gameOver();
                }
               this.xPos = this.xPos - 10;
            }
        }
    }

    function removeBullet(currentShot) {
        currentShots.splice(currentShots.indexOf(currentShot), 1);
    }

    function enemyHit(enemyIndex) {
        invertImageColors(currentEnemies[enemyIndex].xPos, currentEnemies[enemyIndex].yPos);
        currentEnemies[enemyIndex].health = currentEnemies[enemyIndex].health - 50;
        if(currentEnemies[enemyIndex].health <= 0) {
            currentEnemies.splice(enemyIndex, 1);
        }
    }

    function spawnEnemiesIfNeeded() {
        if(this.currentEnemies.length < 20) {
            var mongoEnemy = createMongoEnemy();
            this.currentEnemies.push(mongoEnemy);
        }
    }

    function gameOver() {
        clearInterval(drawInterval);
        clearInterval(spawnEnemyInterval);
        clearInterval(timerInterval);
        gameArea.clear();
        gameArea.drawGameOver();
    }

    function invertImageColors(xPos, yPos) {
        var imageData = this.context.getImageData(xPos, yPos, 100, 100);
        var data = imageData.data;

        for(var i = 0; i < data.length; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
        this.context.putImageData(imageData, xPos, yPos);
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }



</script>
</body>
</html>

