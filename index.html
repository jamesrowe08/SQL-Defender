<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body onload="startGame()">
<script>
	var SPEED_INCREMENT = 8;
	var SPEED_DECREMENT = SPEED_INCREMENT / 2;
	var MAX_SPEED = SPEED_INCREMENT * 3;
	var CURSOR_COUNTDOWN = 20;
	var LEAF_HEIGHT = 100;
	var LEAF_WIDTH = 45;

    var wattImage = new Image();
    var mongoImage = new Image();
	var mongoImage2 = new Image();
	var mongoImage3 = new Image();
    var backgroundImage = new Image();

    var wattLoaded = false;
    var mongoLoaded = false;
	var mongoLoaded2 = false;
	var mongoLoaded3 = false;
    var backgroundLoaded = false;

    var canvas = document.createElement('canvas');
    var context;

    var canvasWidth = window.innerWidth - 25;
    var canvasHeight = window.innerHeight - 75;
	var wattWidth = 50;

    var currentShotId = 0;
    var currentEnemyId = 0;

    var currentEnemies = [];
    var currentShots = [];
    var currentBombs = [];

    var drawInterval;
    var spawnEnemyInterval;
    var timerInterval;

	var wattSpeedX = 0;
	var wattSpeedY = 0;
	var shootInterval = 0;
	
    var timer = 0;
	var enemiesKilled = 0;
	var totalEnemies = 0;

    var lastBomb;
    var isBombActive = false;

    var button = [];				//Button map to keep track of which buttons are pressed
	
    onkeydown = function(k) {                           // key down state handler
        button[k.which - 32] = 1;                         // set key flag
	},
    onkeyup = function(k) {                             // key up state handler
        button[k.which - 32] = 0;                         // clear key flag
    }
	
    function startGame() {
        this.context = this.canvas.getContext("2d");
        document.body.appendChild(canvas);

        wattImage.src = "watt.jpg";
        wattImage.onload = function () {
            wattLoaded = true;
        }
        mongoImage.src = "mongo.png";
        mongoImage.onload = function() {
            mongoLoaded = true;
        }
		mongoImage2.src = "mongo2.png";
        mongoImage2.onload = function() {
            mongoLoaded2 = true;
        }
		mongoImage3.src = "mongo3.png";
        mongoImage3.onload = function() {
            mongoLoaded3 = true;
        }
        backgroundImage.src = "sqlbackground.jpg";
        backgroundImage.onload = function() {
            backgroundLoaded = true;
        }

        drawInterval = setInterval(drawAllEntities, 50);
        spawnEnemyInterval = setInterval(spawnEnemiesIfNeeded, 500);
        timerInterval = setInterval(function() {
            timer++;
        }, 1000);
	
    }

    function drawAllEntities() {
	
        gameArea.clear();	
        gameArea.draw();

		// Handle user input
		// 	button[0] = fire           [space bar]
		// 	button[5] = thrust left    [left arrow]
		// 	button[7] = thrust right   [right arrow]
		// 	button[6] = climb          [up arrow]
		// 	button[8] = dive           [down arrow]
		// 	button[35] = cursor        [c key]
        if (button[0]) {
			if (shootInterval == 0) {
				watt.shoot();
				shootInterval = 3;
			}
		}
		if (button[5]) {
			wattSpeedX = wattSpeedX - SPEED_INCREMENT;
		}
		if (button[7]) {
			wattSpeedX = wattSpeedX + SPEED_INCREMENT;
		}
		if (button[6]) {
			wattSpeedY = wattSpeedY - SPEED_INCREMENT;
		}
		if (button[8]) {
			wattSpeedY = wattSpeedY + SPEED_INCREMENT;
		}
		if (button[35]) {
			watt.dropBomb();
		}
		
		//Cap the max speed
        if (wattSpeedX > MAX_SPEED) {
            wattSpeedX = MAX_SPEED;
        }
        if (wattSpeedX < -MAX_SPEED) {
            wattSpeedX = -MAX_SPEED;
        }
        if (wattSpeedY > MAX_SPEED) {
            wattSpeedY = MAX_SPEED;
        }
        if (wattSpeedY < -MAX_SPEED) {
            wattSpeedY = -MAX_SPEED;
        }
		
		// Move Watt
		watt.xPos = watt.xPos + wattSpeedX;
		watt.yPos = watt.yPos + wattSpeedY;
		
        if (watt.xPos < 0) {
            watt.xPos = 0;
        }
        if (watt.xPos > canvasWidth - wattWidth) {
            watt.xPos = canvasWidth - wattWidth;
        }
        if (watt.yPos < 0) {
            watt.yPos = 0;
        }
        if (watt.yPos > canvasHeight - wattWidth) {
            watt.yPos = canvasHeight - wattWidth;
        }
		
		watt.draw();

		//Slow Watt down
		if (wattSpeedX > 0) {
			wattSpeedX = wattSpeedX - SPEED_DECREMENT > 0 ? wattSpeedX - SPEED_DECREMENT : 0;
		}
		else if (wattSpeedX < 0) {
			wattSpeedX = wattSpeedX + SPEED_DECREMENT < 0 ? wattSpeedX + SPEED_DECREMENT : 0;
		}
		if (wattSpeedY > 0) {
			wattSpeedY = wattSpeedY - SPEED_DECREMENT > 0 ? wattSpeedY - SPEED_DECREMENT : 0;
		}
		else if (wattSpeedY < 0) {
			wattSpeedY = wattSpeedY + SPEED_DECREMENT < 0 ? wattSpeedY + SPEED_DECREMENT : 0;
		}
		
		//Decrement the shoot interval
		if (shootInterval > 0) {
			shootInterval = shootInterval - 1;
		}

        for(var i = 0; i < this.currentShots.length; i++) {
            currentShots[i].draw();
        }

        for(var i =0; i < this.currentEnemies.length; i++) {
            currentEnemies[i].draw();
            currentEnemies[i].doMove();
        }

        for(var i = 0; i < this.currentBombs.length; i++) {
            currentBombs[i].draw();
        }
    }

    var gameArea = {
        draw: function () {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.position = "absolute";
            canvas.style.border = "1px solid";
            if (backgroundLoaded) {	
                context.drawImage(backgroundImage, 0, 0, canvasWidth, canvasHeight);
            }
			
			document.getElementById("mongosKilled").innerHTML = enemiesKilled + "/" + totalEnemies;
			document.getElementById("timeOnSoapBox").innerHTML = timer;
			if (lastBomb != null && timer - lastBomb < 20) {
				document.getElementById("cursorStatus").innerHTML = 'Full Table Scan (' + (CURSOR_COUNTDOWN - (timer - lastBomb)) + ' seconds remaining)';
			}
			else {
				document.getElementById("cursorStatus").innerHTML = 'Available';
			}			
        },
        drawGameOver: function() {
            context.fillStyle = 'black';
            context.font = '25pt Calibri';
            wrapText(context, "Transaction (Process ID 'Watt') was deadlocked with another process and has been chosen as the deadlock victim. Watt fought valiantly, but alas - he could only protect SQL Server for " + timer + " seconds. He was able to fight off " + enemiesKilled + " MongoDB instances but it's neverending list of features and infinite scalability eventually overwhelmed him. Webscale Complete!", 100, 100, canvasWidth - 100, 100);
        },
        clear: function () {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

    }


    var watt = {
        yPos: this.canvas.height / 2,
        xPos: 10,
        draw: function() {
            if(wattLoaded) {
                context.drawImage(wattImage, watt.xPos, watt.yPos, wattWidth, wattWidth);            
			}
        },
        shoot: function() {
            var shot = {
                id: currentShotId++,
                xPos : watt.xPos + (wattWidth / 2) + 10,
                yPos : watt.yPos + (wattWidth / 2),
                draw: function() {
                    context.fillStyle = 'white';
                    context.font = '12pt Calibri';
                    context.fillText("DACPAC", this.xPos, this.yPos);
                    this.xPos = this.xPos + 50;
                    if(this.xPos > canvasWidth) {
                        removeBullet(this);
                    }

                    for(var i =0; i < currentEnemies.length; i++) {
                        if (currentEnemies[i].xPos < this.xPos + 10 &&
                                currentEnemies[i].xPos + 100 > this.xPos &&
                                currentEnemies[i].yPos < this.yPos + 10 &&
                                100 + currentEnemies[i].yPos > this.yPos) {
                             enemyHit(i);
                            removeBullet(this);
                        }
                    }
                }
            }
            currentShots.push(shot);
        },
        dropBomb: function() {
            if (lastBomb == null || timer - lastBomb > CURSOR_COUNTDOWN) {
                lastBomb = timer;
				for(var x = -20; x <= 20; x = x + 5) {
					for(var y = -20; y <= 20; y = y + 5) {
						currentBombs.push(createBomb(x,y));
					}
				}
				enemiesKilled += currentEnemies.length;
				currentEnemies = [];
			}
		}
    }

    function createBomb(movementX, movementY) {
        return bomb = {
            xPos: watt.xPos,
            yPos: watt.yPos,
            movementX: movementX,
            movementY: movementY,
            bombTime: timer,
            draw: function() {
                isBombActive = true;
                //Clear bomb from array
                if(timer - this.bombTime > 5) {
                    currentBombs = [];
                    isBombActive = false;
                }
				context.fillStyle = 'white';
                context.font = '16pt Calibri';
                context.fillText("CURSOR", this.xPos, this.yPos);
                this.xPos = this.movementX + this.xPos;
                this.yPos = this.movementY + this.yPos;
            }
        }
    }

    function createMongoEnemy() {
        return mongoEnemy = {
            id: currentEnemyId++,
            health: 3,
            xPos: canvasWidth + 10,
            yPos: Math.floor((Math.random() * canvasHeight) + 1),
            speed: Math.floor(Math.random() * (30 - 10 + 1)) + 10 + (Math.floor(timer)),
			ySpeed: Math.floor(Math.random() * (20)) * (Math.floor(Math.random() * (2)) == 0 ? -1 : 1),
            draw: function () {
				if (this.health == 3) {
					if(mongoLoaded) {
						context.drawImage(mongoImage, this.xPos, this.yPos, LEAF_WIDTH, LEAF_HEIGHT);
					}
				}
				else if (this.health == 2) {
					if(mongoLoaded2) {
						context.drawImage(mongoImage2, this.xPos, this.yPos, LEAF_WIDTH, LEAF_HEIGHT);
					}
				}
				else {
					if(mongoLoaded3) {
						context.drawImage(mongoImage3, this.xPos, this.yPos, LEAF_WIDTH, LEAF_HEIGHT);
					}
				}
            },
            doMove: function() {
                if(this.xPos < 0) {
                    var index = currentEnemies.indexOf(this);
                    if(index != -1) {
                        currentEnemies.splice(index, 1);
                    }
                }
				//Check if Watt was destroyed
                if (this.xPos < watt.xPos + 50 &&
                        this.xPos + LEAF_WIDTH > watt.xPos &&
                        this.yPos < watt.yPos + 50 &&
                        LEAF_HEIGHT + this.yPos > watt.yPos) {
                    gameOver();
                }
                this.xPos = this.xPos - this.speed;
				this.yPos += this.ySpeed;
				if (this.yPos < 0) {
					this.yPos = 0;
					this.ySpeed = -this.ySpeed;
				}
				else if (this.yPos > (canvasHeight - LEAF_HEIGHT)) {
					this.yPos = canvasHeight - LEAF_HEIGHT;
					this.ySpeed = -this.ySpeed;
				}
            }
        }
    }

    function removeBullet(currentShot) {
        currentShots.splice(currentShots.indexOf(currentShot), 1);
    }

    function enemyHit(enemyIndex) {
        invertImageColors(currentEnemies[enemyIndex].xPos, currentEnemies[enemyIndex].yPos);
        currentEnemies[enemyIndex].health = currentEnemies[enemyIndex].health - 1;
        if(currentEnemies[enemyIndex].health <= 0) {
            currentEnemies.splice(enemyIndex, 1);
			enemiesKilled += 1;
        }
    }

    function spawnEnemiesIfNeeded() {
        if (this.currentEnemies.length < 40 && !isBombActive) {
            var mongoEnemy = createMongoEnemy();
            this.currentEnemies.push(mongoEnemy);
			totalEnemies += 1;
        }
    }

    function gameOver() {
        clearInterval(drawInterval);
        clearInterval(spawnEnemyInterval);
        clearInterval(timerInterval);
        setInterval(function () {
			gameArea.clear();
			gameArea.drawGameOver();
        }, 500)
    }

    function invertImageColors(xPos, yPos) {
        /*
		var imageData = this.context.getImageData(xPos, yPos, 45, 100);
        var data = imageData.data;

        for(var i = 0; i < data.length; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
        this.context.putImageData(imageData, xPos, yPos);
		*/
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }


</script>
<div style="float:right">
	<b>Controls</b>
	<div>Arrow keys to move, Space to shoot, C to run a cursor</div>
	<div>Cursor Status: <span id='cursorStatus' style="font-weight:bold">Available</span></div>
</div>	
<div>
	<b>Score</b>
	<div>Time on Soap Box: <span id='timeOnSoapBox' style="font-weight:bold">0</span><span style="font-weight:bold"> seconds</span></div>
	<div>Mongo Instances Killed: <span id='mongosKilled' style="font-weight:bold">0/0</span></div>
<div>
</body>
</html>

